---
title: "《学透Spring》"
subtitle: "从入门到项目实战"
date: 2023-03-12T11:03:32+08:00
lastmod: 2023-03-12T11:03:32+08:00
draft: true
tags: [BookSummary,Java,Spring]
categories: [BookSummary]
url: /posts/book/9787115609113/
edit:
  enable: true
--- 

数据资料： 《[学透Spring](/posts/book/9787115609113/)》

## 一、初识Spring

`Spring FrameWork`、`Spring Boot`、`Spring Cloud`、`Spring Data`

> 注意各模块的依赖版本支持情况，以及框架支持的JDK版本情况

Spring Initializr：[官方Initizlizr](https://start.spring.io/)和[Aliyun Initializr](https://start.aliyun.com/)

## 二、Spring FrameWork中的IoC容器

### 2.1 IoC容器基础知识

#### 2.1.1 IoC容器

{{< mermaid >}}
flowchart LR
    业务对象-->容器[Spring 容器]--得到-->完全就绪的系统
    配置元数据-->容器
{{</mermaid>}}

#### 2.1.2 容器初始化步骤

|步骤|内容|
|---:|:---|
|1|从xml文件、Java类或其他地方加载配置元数据|
|2|通过BeanFactoryPostProcessor对配置元数据进行一轮处理|
|3|初始化Bean实例，并根据给定的依赖关系组装对象|
|4|通过BeanPostProcessor对Bean进行处理，器件会粗发Bean被构造后的回调|

xml文件方式初始化IoC容器

```xml
<beans xxx>
    <bean id="hello" class="learning.spring.helloworld.Hello" />
</beans>
```

```java
// 根据xml文件初始化BeanFactory
BeanFactory beanFactory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
reader.loadBeanDefinitions("beans.xml");
// 从IoC容器中读取Bean（两种方式）
// Hello hello = (Hello) beanFactory.getBean("hello");
Hello hello = beanFactory.getBean("hello", Hello.class);
hello.sayHello();
```

#### 2.1.3 BeanFactory与ApplicationContext

ApplicationContext继承BeanFactory，增加企业级应用所需的更多特性，通过ApplicationContext发挥Spring上下文的能力

{{< mermaid >}}
flowchart BT
    说明1[从classpath加载xml文件配置]-.->ClassPathXmlApplicationContext-->ApplicationContext-->BeanFactory
    说明2[从文件系统加载xml文件配置]-.->FileSystemXmlApplicationContext-->ApplicationContext
    说明3[根据注解或Java类配置]-.->AnnotionConfigApplicationContext-->ApplicationContext
{{</mermaid>}}

```java
// 根据xml文件初始化容器
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
// 从IoC容器读取Bean
Hello hello = applicationContext.getBean("hello", Hello.class);
hello.sayHello();
```

#### 2.1.4 容器的继承

容器继承：子上下文可以看到父上下文定义的Bean，反之则不行；可以定义同ID的Bean，各自都能获取自己定义的Bean。

```java
ApplicationContext parentContext = new ClassPathXmlApplicationContext("parent-beans.xml");
ApplicationContext childContext = new ClassPathXmlApplicationContext(new String[]{"parent-beans.xml"}, true, parentContext);
```

### 2.2 Bean基础知识

#### 2.2.1 Bean

<details>
<summary>Bean是指Java中的`可重用软件组件`</summary>

- Bean的名称
- Bean的具体类信息，全限定类名
- Bean的作用域，单例（每次都是同一个对象）还是原型（每次都是一个新对象）
- 依赖注入相关信息，构造方法参数、属性以及自动织入方式
- 创建销毁相关信息，懒加载模式、初始化回调方法和销毁回调方法

</details>

#### 2.2.2 Bean的依赖关系

两种注入方式：基于`构造方法`的注入和基于`Setter方法`的注入

|方法|java类模块|xml样例|
|---|---|---|
|构造方法|`public Hello(String name){}`|`<bean ...><constructor-arg value="李雷"/></bean>`[^constructor-arg]|
|Setter方法|`private String name`|`<bean ...><property value="李雷"/></bean>`|

[^constructor-arg]: [Spring中constructor-arg子标签](https://blog.csdn.net/S_Tian/article/details/103824017)

> **自动织入**：自动织入方式可选no、byName、byType和constructor；多个候选Bean可选配置`autowire-candidate`为false、配置目标Bean注解`@Primary`
>
>  
> **Bean初始化顺序**：`<bean/>`的`depends-on`属性或代码的`@DependsOn`

#### 2.2.3 Bean的三种配置方式

基于xml文件的配置

```xml
<bean id="xxx" class="learning.Spring.Yyy" factory-method="create" />
```

> scope声明Bean作用域，lazy-init声明是否懒加载，depends-on声明初始化顺序

基于注解的配置

|类别|详情|
|---|---|
|Bean创建|`@Compent` `@Service` `@Repository` `@Controller` (`@RestController`)|
|可注入依赖|`@Autowire` `@Resource` `@Inject` `@Value`（注入环境变量）

基于Java类的配置

```java
// Java类的容器配置
@Configuration
@ComponentScan("learning.Spring") // 可省略，默认Config所在包
public class Config{
    @Bean
    @Lazy
    @Scope("prototype")
    public Hello helloBean(){return new Hello();}
}

// 初始化容器
ApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class);
```

### 2.3 定制容器与Bean的行为

#### 2.3.1 Bean的生命周期

{{< mermaid >}}
flowchart LR
    创建对象-->注入依赖-->创建后回调-->正常使用-->销毁前回调-->销毁对象
{{</mermaid>}}

Bean的生命周期中可定制方法

|初始化|销毁|
|---:|:---|
|添加了`@PostConstrut`的方法|添加了`@PreDestory`的方法|
|实现了InitializingBean的afterPropertiesSet()方法|实现了DisposableBean的destory()方法|
|`<bean/>`的init-method或@Bean中的initMethod|`<bean/>`的destroy-method或@Bean中的destroyMethod|

> 其中自动推测销毁Bean时的方法：
>
>  
> 1. `public void close(){}`或`public void shutdown`
> 2. 实现`AutoClosable`或`Closable`接口的`close()`方法

```java
public class  Hello implements DisposableBean{
    @PreDestroy
    public void shutdown(){}
    @Override
    public void destroy() throws Exception{}
    public void close(){}
}
```

#### 2.3.2 Aware接口的应用

让Bean感知到容器的诸多信息

> 例如实现ApplicationContextAware接口用于在Bean中获取容器信息、实现ApplicationEventPublisherAware接口用于荣容器中获取ApplicationEventPublisher实例。

#### 2.3.3 事件机制

容器变动，以ApplicationEvent的子类，在实现ApplicationListener的Bean中（或使用@EventListener）处理变更。

> 多个Bean处理同一个事件，通过`order`注解指定处理顺序

```java
// 方式1：实现ApplicationListener接口方式
@Component
@Order(1)
public class ContextClosedEventListener implements ApplicationListener<ContextClosedEvent>{
    @Override
    public void onApplicationEvent(ContextClosedEvent event){}
}
// 方式2：用注解@EventListener方式
@Component
public class ContextClosedEventAnnotationListener{
    @EventListener
    @Order(2)
    public void onEvent(ContextClosedEvent event){}
}
```

#### 2.3.4 容器的拓展点

**BeanPostProcessor**：Bean的后置处理器接口(初始化前执行postProcessBeforeInitialization()、初始化后执行postProcessAfterInitiazation())

**BeanFactoryPostProcessor**：BeanFactory的后置处理器，BeanFactory加载所有Bean定义但未初始化时执行postProcessBeanFactory()方法

#### 2.3.5 优雅的关闭容器

方式1：让Bean实现Lifecycle接口处理容器的变更；方式2：借助Spring FrameWork的事件机制

```java
public class Hello implements Lifecycle{
    @Override
    public void start(){}
    public void stop(){}
    public boolean isRunning(){}
}
```

### 2.4 容器中的几种抽象

#### 2.4.1 环境抽象

Profile抽象：

||xml方式|代码方式|环境变量|
|---|---|---|---|
|配置|`<beans/>`的profile属性|@Profile注解在@Configuation注解的类上<br/>@Profile注解在@Bean注解的方法上||
|启用||`ConfigurableEnvironment.setActiveProfiles()`指定激活的profile|配置文件指定`spring.profiles.active`环境变量的值|

PropertySource抽象：添加属性来源

|方式|样例|
|---|---|
|xml|`<context:property-placeholder location:"classpath:/META-INF/resources/app.properties" />`|
|注解|`@Configuration`<br/>`@PropertySource("classpath:/META-INF/resources/app.properties")`|

#### 2.4.2 任务抽象

异步执行: 统一的TaskExcutor方便配置多线程相关的细节

> 相关实现：同步的SyncTaskExcutor、SimpleAsyncTaskExecutor、ConcurrentTaskExecutor、ThreadPoolTaskExecutor

定时任务：统一的TaskSchduler方便处理特定时间执行和多次重复执行

> xml方式：`<task:scheduler id="taskScheduler" pool-size="10: />`
>
>  
> 代码方式：使用@EnableSchduling启用后使用@Schduled注解方法启用特定定时任务
