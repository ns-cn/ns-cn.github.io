---
title: "《分布式对象存储-原理、架构及Go语言实现》"
date: 2023-02-19T13:51:32+08:00
lastmod: 2023-02-19T13:51:32+08:00
draft: false
tags: [BookSummary,Go,Cache,DoItYourself]
categories: [BookSummary]
url: /posts/book/9787115480552/
edit:
  enable: true
---

[《分布式对象存储基于Go实现》](https://item.kongfz.com/book/31061048.html)

## 一、对象存储简介

### 1.1 对比传统网络存储

传统网络存储：现代的网络存储通常是混合NAS和SAN使用，同时提供文件级别的协议和块级别的协议。

|类别|功能|协议|
|---|---|---|
|NAS|提供存储功能和文件系统的网络服务器|SMB、NFS以及AFS等|
|SAN|只提供块存储，文件系统的抽象交给客户端|Fibre Channel、AoE等|

传统网络存储和对象存储对比

|区别|传统网络|对象存储|
|---|---|---|
|数据管理方式|以文件或块形式管理|以对象形式进行管理|
|数据访问方式|NFS等网络协议访问|REST网络服务访问对象|
|优势||拓展性、更低的代价提升数据冗余的能力|

### 1.2 单机版对象存储的架构

{{< mermaid >}}
flowchart LR
    subgraph 服务器
    direction LR
        REST接口-->本地磁盘(本地磁盘)
    end
    客户端-->服务器
{{</mermaid >}}

> 最大的问题：拓展性

## 二、可拓展的分布式系统

### 2.1 分布式系统

**三个特点**：`节点之间并发工作`、`没有全局锁`、`节点发生错误不影响其他节点`

**优点**：可拓展性

### 2.2 接口和数据存储分离的架构

通过接口接口服务和数据服务，方便任意添加新的接口节点和服务节点

{{< mermaid >}}
flowchart LR
    subgraph 数据服务层
    数据服务1[数据服务]
    数据服务2[接口服务]
    end
    磁盘1-->数据服务1
    磁盘2-->数据服务2
    subgraph RabbitMQ
        apiExchange
        dataExchange
        消息队列((消息队列))
    end
    subgraph 接口服务层
    接口服务1[接口服务]-.-接口服务2[接口服务]
    end
    接口服务层-->RabbitMQ-->数据服务层
    数据服务层-->RabbitMQ-->接口服务层
    数据服务1-->磁盘1[磁盘]
    数据服务2-->磁盘2[磁盘]
{{</mermaid >}}

|节点|内容|
|---|---|
|接口服务|对外REST接口|
|apiExchange|心跳，每个节点都会收到任意一台数据服务节点的心跳|
|dataExchange|接收接口服务的数据定位消息|
|数据服务|数据存储实际管理|
|消息队列|用于数据的数据服务层通过消息队列通知接口服务|

> 存在问题：
> 
> 1. 数据重复：多次PUT同一对象，在每个节点存在相同节点（数据去重解决）
> 2. 数据不一致：多次PUT同一对象，但数据不同（数据版本解决）

## 三、元数据服务

### 3.1 元数据

元数据指的是对象的描述信息。元数据服务就是提供对元数据的存取功能的服务。包括但不限于文件元数据（名字、版本、大小、散列值等）和用户自定义元数据（照片拍摄时间、歌曲的作者等）。

### 3.2 加入元数据服务的架构

{{< mermaid >}}
flowchart LR
    subgraph 数据服务层
    数据服务1[数据服务]
    数据服务2[接口服务]
    end
    磁盘1-->数据服务1
    磁盘2-->数据服务2
    subgraph RabbitMQ
        apiExchange
        dataExchange
        消息队列((消息队列))
    end
    subgraph 接口服务层
    接口服务1[接口服务]-.-接口服务2[接口服务]
    end
    接口服务层-->RabbitMQ-->数据服务层
    数据服务层-->RabbitMQ-->接口服务层
    数据服务1-->磁盘1[磁盘]
    数据服务2-->磁盘2[磁盘]
    接口服务2-->ES
{{</mermaid >}}

通过ES的HTTP接口作为元数据服务。存储文件信息到元数据服务节点ES，存储文件数据到数据服务。

> 元数据服务的引进：可以实现软删除、版本控制、对象数据的一致性等优点。
> 
> 存在的问题：
> 
> 1. 散列值由客户端提供，可能与实际散列值不一致导致问题。

## 四、数据校验和去重

### 4.1 何为去重

去重是一种消除重复数据多余副本的数据压缩技术。通过基于对象的全局唯一标识符，也就是通过对该对象的散列值进行单例检查实现（依赖数据校验）。

### 4.2 数据校验

**数据校验的作用**：因客户端恶意、BUG或传输异常导致数据实际散列值与客户端提供散列值不一致。需验证客户端提供的散列值和我们自己根据数据计算的散列值一致。

**计算方法** ：传输到数据服务节点的临时对象中，并在传输数据的同时计算其散列值（数据服务增加缓存接口缓存数据到文件中并计算散列值）。

### 4.3 数据上传流程

1. 接口服务调用数据服务缓存文件数据并计算散列值
2. 接口服务验证数据散列值与客户端提供散列值是否一致
3. 如果一致则调用数据服务实际存储该文件
4. 如果不一致则删除临时对象（需增加线程定时清空缓存内容）

> 存在问题：如果唯一的存储实体可能损坏或丢失，则无法恢复

## 五、数据冗余和即时修复

### 5.1 数据冗余

#### 5.1.1 数据丢失和数据不可用

|概念|介绍|是否可恢复|
|:---:|---|:---:|
|数据丢失|在存储、传输或处理过程由于错误或一楼导致损失|否|
|数据不可用|服务器维护等暂时性的维护|是|

依靠数据冗余来对抗数据丢失，在数据丢失时帮助对其进行修复。

#### 5.1.2 对象存储系统的数据冗余策略

|策略|空间大小|抵御能力|
|:---:|:---:|:---:|
|不做冗余|100%|0|
|多副本|200%|1|
|4+2的RS纠错码[^纠错码简介]|`(M+N)/M*100%`|N|

[^纠错码简介]:[纠错码简介](https://blog.csdn.net/qq_31725391/article/details/106035171)

> RS纠错码策略：存储空间的要求更低、抵御数据损坏的能力却更强；拆分分片有助于数据服务层的负载均衡。

### 5.2 关键过程

上传时将文件按4+2拆分多个分片存储；获取时按纠错码流程进行文件恢复或节点不可用时进行文件修复。

## 六、断点续传

### 6.1 断点续传

**断点下载**：GET请求时通过设置Range请求头告诉服务器从什么位置开始输出对象的数据

**断点上传**：POST请求查询服务器上传进度，PUT请求传输数据。

## 七、数据压缩

传输过程压缩节省网络贷款、存储文件压缩节省存储空间（客户端压缩、服务端压缩）。常见压缩算法：bzip2、flate、gzip、lzw和zlib等。

|过程|内容|
|---|---|
|数据服务中临时文件转正时压缩|存储文件压缩|
|数据服务中GET对象时数据解压|
|下载数据时接口服务压缩后传输|传输过程压缩|

## 八、数据维护

**对象版本留存**常见策略

|策略|方案|
|:---:|:---:|
|数量限定策略|保留若干个版本|
|时间限定策略|保留一段固定时间|

**定期检查及修复**：数据的修复不能只依赖即时修复技术来进行。如果长期不修复会因为损坏数据片过多导致无法修复。基本包括如下内容：

1. 删除过期元数据
2. 删除没有元数据引用的对象数据
3. 对象数据的检查和修复
